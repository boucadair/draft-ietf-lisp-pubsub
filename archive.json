{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-02-09T00:44:05.636318+00:00",
  "repo": "boucadair/draft-ietf-lisp-pubsub",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOI2dNNs5dj2ZR",
      "title": "timestamp to prevent replay attacks",
      "url": "https://github.com/boucadair/draft-ietf-lisp-pubsub/issues/1",
      "state": "OPEN",
      "author": "boucadair",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I'm afraid that we need to have a timestamp added to the Map-Request to prevent replay attacks and thus avoid that a replayed Map-Request overwrites an existing subscription and trigger Map-Notify messages.\r\n",
      "createdAt": "2023-02-03T11:15:57Z",
      "updatedAt": "2023-02-06T10:11:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "arnatal",
          "authorAssociation": "COLLABORATOR",
          "body": "This is why we have incremental nonces on control messages. We already have text for how to use the nonce to prevent replay attacks on the Map-Notify exchange, we just need to add a note regarding Map-Requests.",
          "createdAt": "2023-02-03T11:23:20Z",
          "updatedAt": "2023-02-03T11:25:05Z"
        },
        {
          "author": "boucadair",
          "authorAssociation": "OWNER",
          "body": "How incremental nonces prevents replay attacks at the Map-Server?",
          "createdAt": "2023-02-03T12:40:29Z",
          "updatedAt": "2023-02-03T12:40:29Z"
        },
        {
          "author": "arnatal",
          "authorAssociation": "COLLABORATOR",
          "body": "This is what RFC 9301 says for Map-Registers:\r\n\r\n> Nonce: This 8-octet 'Nonce' field is incremented each time a Map-Register message is sent. When a Map-Register acknowledgment is requested, the nonce is returned by Map-Servers in Map-Notify messages. Since the entire Map-Register message is authenticated, the 'Nonce' field serves to protect against Map-Register replay attacks. An ETR that registers to the Mapping System SHOULD store the last nonce sent in persistent storage, so when it restarts, it can continue using an incrementing nonce. If the ETR cannot support saving the nonce, then when it restarts, it MUST use a new authentication key to register to the Mapping System. A Map-Server MUST track and save in persistent storage the last nonce received for each ETR xTR-ID and key pair. If a Map-Register is received with a nonce value that is not greater than the saved nonce, it MUST drop the Map-Register message and SHOULD log the fact that a replay attack could have occurred\r\n\r\nThe PubSub docs follows this to prevent replay attacks for Map-Notify used as publications:\r\n\r\n> If a Map-Notify received as a publication has a nonce value that is not greater than the saved nonce, the xTR drops the Map-Notify message and logs the fact a replay attack could have occurred. The same considerations discussed in Section 5.6 of [[RFC9301](https://www.ietf.org/archive/id/draft-ietf-lisp-pubsub-10.html#RFC9301)] regarding Map-Register nonces apply here for Map-Notify nonces.\r\n\r\nWe would still need to recommend authentication / integrity protection between the xTR and the MR/MS in deployments that could be subject to replay attacks (this aligns with the guidelines on 9301/9303).",
          "createdAt": "2023-02-03T16:34:51Z",
          "updatedAt": "2023-02-03T16:34:51Z"
        },
        {
          "author": "boucadair",
          "authorAssociation": "OWNER",
          "body": "Fully agree on the auth/integrity protection reco. Also, agree that the nonce++ is a good guard against replay attacks of Map-Notify at the ETR. \r\n\r\nHowever, I'm not sure we are good when it comes to Map-Requests:\r\n\r\nRFC9301 says simply:\r\n\r\n>    Nonce:  This is an 8-octet random value created by the sender of the\r\n>       Map-Request.  This nonce will be returned in the Map-Reply.  The\r\n>       nonce is used as an index to identify the corresponding Map-\r\n>       Request when a Map-Reply message is received.  The nonce MUST be\r\n>       generated by a properly seeded pseudo-random source; for example,\r\n>       see [RFC4086].\r\n\r\nPubsub does not enforce any check on the nonce to override an existing state: \r\n\r\n>    If an xTR-ID is successfully added to the list of subscribers for an\r\n>    EID-Record, the Map-Server MUST extract the nonce and ITR-RLOCs\r\n>    present in the Map-Request, and store the association between the\r\n>    EID-Record, xTR-ID, ITR-RLOCs and nonce.  Any already present state\r\n>    regarding ITR-RLOCs and/or nonce for the same xTR-ID MUST be\r\n>    overwritten.\r\n\r\nSo a replayed Map-Request will pass through.\r\n\r\nI think that the situation is even worse when it comes to withdrawal as no check is made on the nonce to use. A replayed Map-Request will always remove installed state:\r\n\r\n>    The following specifies the procedure to remove a subscription.  If\r\n>    the Map-Request only has one ITR-RLOC with AFI = 0 (i.e., Unknown\r\n>    Address), the Map-Server MUST remove the subscription state for that\r\n>    xTR-ID.  In this case, the Map-Server MUST send the Map-Notify to the\r\n>    source RLOC of the Map-Request.\r\n\r\n",
          "createdAt": "2023-02-03T16:59:42Z",
          "updatedAt": "2023-02-03T16:59:42Z"
        },
        {
          "author": "arnatal",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, we're not good as of now. We need to add some text to mention that the nonce should be checked on Map-Request as well. I think that along with the recommendation on Map-Resolvers checking auth/integrity should be enough. ",
          "createdAt": "2023-02-03T17:26:20Z",
          "updatedAt": "2023-02-03T17:26:20Z"
        },
        {
          "author": "boucadair",
          "authorAssociation": "OWNER",
          "body": "Great, thanks...but\r\n\r\nRelying on an incremental nonce will have a side effect for amnesic xTRs  (no persistent storage of nonce) or during maintenance operations without state sync. The xTR can't subscribe since its requests will be discarded because of the hard checks on the nonce. Also, a new xTR can't clear any stale state when it first bootstraps. We can't guarantee that xtr_ids won't be recycled, etc. \r\n\r\nI'm afraid that a mix of nonce++/timestamp is needed:\r\n* nonce/timestamp for first subscription then nonce++/timestamp for updates\r\n* no check on the nonce but require a nonce/timestamp for deletion\r\n\r\nWhat do you think?\r\n\r\n\r\n",
          "createdAt": "2023-02-03T17:36:51Z",
          "updatedAt": "2023-02-03T17:53:41Z"
        },
        {
          "author": "arnatal",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the issue with amnesic xTRs was discussed during the 9301 standardisation process. As outcome, RFC9301 now reads:\r\n\r\n> A Map-Server MUST track and save in persistent storage the last nonce\r\n\r\nWhich doesn't leave really much room for amnesic xTRs. I think we should align with 9301.",
          "createdAt": "2023-02-03T17:53:04Z",
          "updatedAt": "2023-02-03T17:53:04Z"
        },
        {
          "author": "boucadair",
          "authorAssociation": "OWNER",
          "body": "The same para from where you extracted the quote also says: \r\n\r\n> An ETR that registers to the Mapping System SHOULD store\r\n>       the last nonce sent in persistent storage, so when it restarts, it\r\n>       can continue using an incrementing nonce.  If the ETR cannot\r\n>       support saving the nonce, then when it restarts, it MUST use a new\r\n>       authentication key to register to the Mapping System.\r\n\r\nIsn't odd to have a MUST for xTR for nonce storage for Map-Requests, while this is only a SHOULD for Map-Register?",
          "createdAt": "2023-02-03T18:02:08Z",
          "updatedAt": "2023-02-03T18:02:08Z"
        },
        {
          "author": "arnatal",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry I had in mind the MS, you\u2019re right that we ended up with a SHOULD for ETRs and Map-Register. If we want to support a SHOULD also for ITRs and Map-Requests, one option is indeed to explore the timestamp route. Unfortunately, that would depart from the rest of the LISP architecture where timestamps are not used (afaik). I wonder if we could find a way to handle this that does not require to introduce a new concept in LISP (also we prevent unexpected side effects, if any). \r\n\r\nThinking on this, I wonder if the solution might be on Section 7.1 of PubSub. There we describe a tamper-proof way to subscribe and create a security association (provided the security guidelines of PubSub, 9301, and 9303 are followed). How about we specify that for scenarios subject to replay attacks that include ITRs that lose state (non-persistent storage) the procedure described in Section 7.1 MUST be followed to restart the nonce (the MS needs to check that the OTK that restarts the nonce has been not used before of course). This would be equivalent to ETRs on 9301 that require to use a new authentication key when persistent storage is not an option. What do you think?",
          "createdAt": "2023-02-05T15:37:26Z",
          "updatedAt": "2023-02-05T15:37:26Z"
        },
        {
          "author": "boucadair",
          "authorAssociation": "OWNER",
          "body": "> Sorry I had in mind the MS, you\u2019re right that we ended up with a SHOULD for ETRs and Map-Register. If we want to support a SHOULD also for ITRs and Map-Requests, one option is indeed to explore the timestamp route. Unfortunately, that would depart from the rest of the LISP architecture where timestamps are not used (afaik). I wonder if we could find a way to handle this that does not require to introduce a new concept in LISP (also we prevent unexpected side effects, if any).\r\n> \r\n\r\nACK. This is not used currently but pubsub have specifics. However, it is pragmatic to explore first the other option below. \r\n\r\n> Thinking on this, I wonder if the solution might be on Section 7.1 of PubSub. There we describe a tamper-proof way to subscribe and create a security association (provided the security guidelines of PubSub, 9301, and 9303 are followed). \r\n\r\nI assume this will cover also adding an explicit mention that we deviate from 5.2 of 9301 for nonce generation for sub updates (for whatever reason local to the xTR): The nonce++ of Map-Request for a specific EID used by the xTR (updates) should be based on the nonce seen in the latest (authenticated) map-notify. \r\n\r\n> How` about we specify that for scenarios subject to replay attacks that include ITRs that lose state (non-persistent storage) the procedure described in Section 7.1 MUST be followed to restart the nonce (the MS needs to check that the OTK that restarts the nonce has been not used before of course). This would be equivalent to ETRs on 9301 that require to use a new authentication key when persistent storage is not an option. What do you think?\r\n\r\nThe MS will accept an update/withdrawal, if nonce++ or new distinct nonce but with a new authentication key. I think this would work but this has scalability issues as the MS has to store every key-id used in a Map-Request. Otherwise, the replayed message can pass through when when that key was removed from the MS logs.  I expect also comments about how to ensure that a distinct key is used when restarts especially for xTR without permanent storage, though.  \r\n\r\nBTW, I started https://github.com/boucadair/lisp-pubsub-flow-examples to exercise the spec and illustrate the expected behavior. The current version assumes the nonce++/key-id storage approach.\r\n",
          "createdAt": "2023-02-06T10:11:14Z",
          "updatedAt": "2023-02-06T10:11:14Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOI2dNNs5dj2vg",
      "title": "side effects of rate-limits (from Magnus)",
      "url": "https://github.com/boucadair/draft-ietf-lisp-pubsub/issues/2",
      "state": "OPEN",
      "author": "boucadair",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "> Also beyond rate limiting, is there a possibility here to reject the MAP-requests from a source address, without causing a denial of service attack possibility? My shallow review seem to indicate that there exist such a risk. What I am considering is that there is a legit xTR (B) with IP (IP-B). If the attacker sends a MAP-Request with nonce-A, with IP source address IP-B. The Map-Notify will go to B. B can\u2019t map this to a request it made as no Nonce matches what it sends and discards the message. Thus, the map server getting a mix of legit and spoofed requests may decide to band IP-B from asking things, thus enabling a denial of service on B. ",
      "createdAt": "2023-02-03T11:17:03Z",
      "updatedAt": "2023-02-03T11:21:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "boucadair",
          "authorAssociation": "OWNER",
          "body": "For this attack to work, the spoofed request should include a valid xTR-ID and passes the authentication checks at the Map-Server.\r\n\r\nAn attacker who has access to the keys can do more harm. ",
          "createdAt": "2023-02-03T11:19:29Z",
          "updatedAt": "2023-02-03T11:19:29Z"
        },
        {
          "author": "arnatal",
          "authorAssociation": "COLLABORATOR",
          "body": "Technically the checks are passed at the Map-Resolver, who should verify the integrity and authenticity of the Map-Request, (and potentially to check if the xTR is allowed to subscribe). ",
          "createdAt": "2023-02-03T11:21:19Z",
          "updatedAt": "2023-02-03T11:21:19Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOI2dNNs5dz57w",
      "title": "Explicit entries",
      "url": "https://github.com/boucadair/draft-ietf-lisp-pubsub/issues/3",
      "state": "OPEN",
      "author": "boucadair",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": ">    The subscription state can also be created explicitly by\r\n>    configuration at the Map-Server (possible when a pre-shared security\r\n>    association exists, see Section 7).  In this case, the initial nonce\r\n>    associated with the xTR-ID (and EID-Record) MUST be randomly\r\n>    generated by the Map-Server.\r\n\r\nThe behavior is underspecified.",
      "createdAt": "2023-02-07T08:22:44Z",
      "updatedAt": "2023-02-07T08:22:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOI2dNNs5d0QBJ",
      "title": "Handling subscription withdrawals but no state found",
      "url": "https://github.com/boucadair/draft-ietf-lisp-pubsub/issues/4",
      "state": "OPEN",
      "author": "boucadair",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": ">    The following specifies the procedure to remove a subscription.  If\r\n>    the Map-Request only has one ITR-RLOC with AFI = 0 (i.e., Unknown\r\n>    Address), the Map-Server MUST remove the subscription state for that\r\n>    xTR-ID.  In this case, the Map-Server MUST send the Map-Notify to the\r\n>    source RLOC of the Map-Request.\r\n\r\nI suggest we indicate that a Map-Notify will be sent back by the Map-Server even if no subscription is found.",
      "createdAt": "2023-02-07T09:26:45Z",
      "updatedAt": "2023-02-07T09:26:45Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 5,
      "id": "PR_kwDOI2dNNs5JiKWZ",
      "title": "Add an informative reference to the sample-flow pubsub I-D",
      "url": "https://github.com/boucadair/draft-ietf-lisp-pubsub/pull/5",
      "state": "OPEN",
      "author": "boucadair",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-08T15:02:43Z",
      "updatedAt": "2023-02-08T15:02:43Z",
      "baseRepository": "boucadair/draft-ietf-lisp-pubsub",
      "baseRefName": "main",
      "baseRefOid": "68e5b4fc469cf8000d95f4fe1182c10fe0afece0",
      "headRepository": "boucadair/draft-ietf-lisp-pubsub",
      "headRefName": "boucadair-patch-1",
      "headRefOid": "fa4c3649c82e1e57d6cfd141ecaca368bfc39337",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}